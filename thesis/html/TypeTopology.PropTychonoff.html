<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>TypeTopology.PropTychonoff</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Background">Martin Escardo 29 April 2014.

A proposition-indexed product of pointed compact sets is itself
compact. But the assumption that a proposition-indexed product of
compact sets is compact gives weak excluded middle (negative
propositions are decidable).

The definition of compactness (or exhaustive searchability) is

    compact∙ A = (p : A → 𝟚) → Σ a₀ ꞉ A , p a₀ ＝ ₁ → (a : A) → p a ＝ ₁

With excluded middle for propositions, the above claim is not
surprising, because

    (𝟘 → Y) = Y^𝟘 ≃ 𝟙 (which is always compact),
    (𝟙 → Y) = Y^𝟙 ≃ Y (which is compact if Y is),

and excluded middle for a proposition X amounts to X = 𝟘 or X = 𝟙, so
that

    Y^X is compact if Y is compact and X is a proposition.

The point is that

    (1) We can reach this conclusion without excluded middle.

    (2) This also holds for dependent products:

        Π x : X , Y x is compact if X is a proposition and Y x is
        compact for every x : X.

        (This product is also written (x : X) → Y x or Π Y in Agda.)

Our Agda proof below can be written rather concisely by expanding the
definitions. We deliberately don&#39;t do that, so that we have a rigorous
informal proof side-by-side with the formal proof. We proceed in a
series of trivial steps, hopefully in the most natural way (although
we had a convoluted path to this supposedly natural way).

</a><a id="1345" class="Markup">\begin{code}</a>

<a id="1359" class="Symbol">{-#</a> <a id="1363" class="Keyword">OPTIONS</a> <a id="1371" class="Pragma">--safe</a> <a id="1378" class="Pragma">--without-K</a> <a id="1390" class="Pragma">--exact-split</a> <a id="1404" class="Symbol">#-}</a>

<a id="1409" class="Keyword">open</a> <a id="1414" class="Keyword">import</a> <a id="1421" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>

<a id="1435" class="Keyword">open</a> <a id="1440" class="Keyword">import</a> <a id="1447" href="UF.FunExt.html" class="Module">UF.FunExt</a>

<a id="1458" class="Keyword">module</a> <a id="1465" href="TypeTopology.PropTychonoff.html" class="Module">TypeTopology.PropTychonoff</a> <a id="1492" class="Symbol">(</a><a id="1493" href="TypeTopology.PropTychonoff.html#1493" class="Bound">fe</a> <a id="1496" class="Symbol">:</a> <a id="1498" href="UF.FunExt.html#970" class="Function">FunExt</a><a id="1504" class="Symbol">)</a> <a id="1506" class="Keyword">where</a>

<a id="1513" class="Keyword">open</a> <a id="1518" class="Keyword">import</a> <a id="1525" href="MLTT.Two-Properties.html" class="Module">MLTT.Two-Properties</a>
<a id="1545" class="Keyword">open</a> <a id="1550" class="Keyword">import</a> <a id="1557" href="TypeTopology.CompactTypes.html" class="Module">TypeTopology.CompactTypes</a>
<a id="1583" class="Keyword">open</a> <a id="1588" class="Keyword">import</a> <a id="1595" href="UF.Base.html" class="Module">UF.Base</a>
<a id="1603" class="Keyword">open</a> <a id="1608" class="Keyword">import</a> <a id="1615" href="UF.Equiv.html" class="Module">UF.Equiv</a>
<a id="1624" class="Keyword">open</a> <a id="1629" class="Keyword">import</a> <a id="1636" href="UF.EquivalenceExamples.html" class="Module">UF.EquivalenceExamples</a>
<a id="1659" class="Keyword">open</a> <a id="1664" class="Keyword">import</a> <a id="1671" href="UF.PropIndexedPiSigma.html" class="Module">UF.PropIndexedPiSigma</a>
<a id="1693" class="Keyword">open</a> <a id="1698" class="Keyword">import</a> <a id="1705" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>

<a id="1723" class="Markup">\end{code}</a><a id="1733" class="Background">

A crucial lemma is

    prop-indexed-product : is-prop X → (a : X) → Π Y ≅ Y a

This is proved in the module Prop-indexed-product. Although it has a
subtle proof, it should be intuitively clear, as X has at most one
element by hypothesis, and if the element is a:X then the product Π Y
should be isomorphic to its only factor Y a.

With this observation, the following proof should be self-contained,
if we recall again the definition of compact set from the module
CompacTypes:

    compact∙ A = (p : A → 𝟚) → Σ a₀ ꞉ A , p a₀ ＝ ₁ → (a : A) → p a ＝ ₁

Recall also that such an a₀ is called a universal witness for the predicate p.

</a><a id="2367" class="Markup">\begin{code}</a>

<a id="prop-tychonoff"></a><a id="2381" href="TypeTopology.PropTychonoff.html#2381" class="Function">prop-tychonoff</a> <a id="2396" class="Symbol">:</a> <a id="2398" class="Symbol">{</a><a id="2399" href="TypeTopology.PropTychonoff.html#2399" class="Bound">X</a> <a id="2401" class="Symbol">:</a> <a id="2403" href="MLTT.Universes.html#265" class="Generalizable">𝓤</a> <a id="2405" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="2407" class="Symbol">}</a> <a id="2409" class="Symbol">{</a><a id="2410" href="TypeTopology.PropTychonoff.html#2410" class="Bound">Y</a> <a id="2412" class="Symbol">:</a> <a id="2414" href="TypeTopology.PropTychonoff.html#2399" class="Bound">X</a> <a id="2416" class="Symbol">→</a> <a id="2418" href="MLTT.Universes.html#267" class="Generalizable">𝓥</a> <a id="2420" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="2422" class="Symbol">}</a>
               <a id="2439" class="Symbol">→</a> <a id="2441" href="UF.Subsingletons.html#484" class="Function">is-prop</a> <a id="2449" href="TypeTopology.PropTychonoff.html#2399" class="Bound">X</a>
               <a id="2466" class="Symbol">→</a> <a id="2468" class="Symbol">((</a><a id="2470" href="TypeTopology.PropTychonoff.html#2470" class="Bound">x</a> <a id="2472" class="Symbol">:</a> <a id="2474" href="TypeTopology.PropTychonoff.html#2399" class="Bound">X</a><a id="2475" class="Symbol">)</a> <a id="2477" class="Symbol">→</a> <a id="2479" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="2491" class="Symbol">(</a><a id="2492" href="TypeTopology.PropTychonoff.html#2410" class="Bound">Y</a> <a id="2494" href="TypeTopology.PropTychonoff.html#2470" class="Bound">x</a><a id="2495" class="Symbol">))</a>
               <a id="2513" class="Symbol">→</a> <a id="2515" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="2527" class="Symbol">(</a><a id="2528" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="2530" href="TypeTopology.PropTychonoff.html#2410" class="Bound">Y</a><a id="2531" class="Symbol">)</a>
<a id="2533" href="TypeTopology.PropTychonoff.html#2381" class="Function">prop-tychonoff</a> <a id="2548" class="Symbol">{</a><a id="2549" href="TypeTopology.PropTychonoff.html#2549" class="Bound">𝓤</a><a id="2550" class="Symbol">}</a> <a id="2552" class="Symbol">{</a><a id="2553" href="TypeTopology.PropTychonoff.html#2553" class="Bound">𝓥</a><a id="2554" class="Symbol">}</a> <a id="2556" class="Symbol">{</a><a id="2557" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="2558" class="Symbol">}</a> <a id="2560" class="Symbol">{</a><a id="2561" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="2562" class="Symbol">}</a> <a id="2564" href="TypeTopology.PropTychonoff.html#2564" class="Bound">X-is-prop</a> <a id="2574" href="TypeTopology.PropTychonoff.html#2574" class="Bound">ε</a> <a id="2576" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="2578" class="Symbol">=</a> <a id="2580" href="TypeTopology.PropTychonoff.html#6974" class="Function">γ</a>
 <a id="2583" class="Keyword">where</a>
  <a id="2591" href="TypeTopology.PropTychonoff.html#2591" class="Function">have</a> <a id="2596" class="Symbol">:</a> <a id="2598" class="Symbol">(</a><a id="2599" href="Notation.General.html#2131" class="Function">type-of</a> <a id="2607" href="TypeTopology.PropTychonoff.html#2574" class="Bound">ε</a> <a id="2609" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="2611" class="Symbol">((</a><a id="2613" href="TypeTopology.PropTychonoff.html#2613" class="Bound">x</a> <a id="2615" class="Symbol">:</a> <a id="2617" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="2618" class="Symbol">)</a> <a id="2620" class="Symbol">→</a> <a id="2622" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a><a id="2633" class="Symbol">(</a><a id="2634" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="2636" href="TypeTopology.PropTychonoff.html#2613" class="Bound">x</a><a id="2637" class="Symbol">)))</a>
       <a id="2648" href="MLTT.Sigma.html#572" class="Function Operator">×</a> <a id="2650" class="Symbol">(</a><a id="2651" href="Notation.General.html#2131" class="Function">type-of</a> <a id="2659" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="2661" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="2663" class="Symbol">(</a><a id="2664" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="2666" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="2668" class="Symbol">→</a> <a id="2670" href="MLTT.Two.html#138" class="Datatype">𝟚</a><a id="2671" class="Symbol">))</a>
  <a id="2676" href="TypeTopology.PropTychonoff.html#2591" class="Function">have</a> <a id="2681" class="Symbol">=</a> <a id="2683" href="MLTT.Identity-Type.html#172" class="InductiveConstructor">refl</a> <a id="2688" href="MLTT.Sigma.html#409" class="InductiveConstructor Operator">,</a> <a id="2690" href="MLTT.Identity-Type.html#172" class="InductiveConstructor">refl</a>

  <a id="2698" href="TypeTopology.PropTychonoff.html#2698" class="Function">hip</a> <a id="2702" class="Symbol">:</a> <a id="2704" class="Symbol">(</a><a id="2705" href="TypeTopology.PropTychonoff.html#2705" class="Bound">x</a> <a id="2707" class="Symbol">:</a> <a id="2709" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="2710" class="Symbol">)</a> <a id="2712" class="Symbol">→</a> <a id="2714" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="2716" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="2718" href="UF.Equiv.html#1267" class="Function Operator">≃</a> <a id="2720" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="2722" href="TypeTopology.PropTychonoff.html#2705" class="Bound">x</a>
  <a id="2726" href="TypeTopology.PropTychonoff.html#2698" class="Function">hip</a> <a id="2730" class="Symbol">=</a> <a id="2732" href="UF.PropIndexedPiSigma.html#1172" class="Function">prop-indexed-product</a> <a id="2753" class="Symbol">(</a><a id="2754" href="TypeTopology.PropTychonoff.html#1493" class="Bound">fe</a> <a id="2757" href="TypeTopology.PropTychonoff.html#2549" class="Bound">𝓤</a> <a id="2759" href="TypeTopology.PropTychonoff.html#2553" class="Bound">𝓥</a><a id="2760" class="Symbol">)</a> <a id="2762" href="TypeTopology.PropTychonoff.html#2564" class="Bound">X-is-prop</a>

<a id="2773" class="Markup">\end{code}</a><a id="2783" class="Background">

The essence of the first part of the proof is this:

</a><a id="2838" class="Markup">\begin{code}</a>

  <a id="2854" href="TypeTopology.PropTychonoff.html#2854" class="Function">crude</a> <a id="2860" class="Symbol">:</a> <a id="2862" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a> <a id="2864" class="Symbol">→</a> <a id="2866" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="2878" class="Symbol">(</a><a id="2879" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="2881" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="2882" class="Symbol">)</a>
  <a id="2886" href="TypeTopology.PropTychonoff.html#2854" class="Function">crude</a> <a id="2892" href="TypeTopology.PropTychonoff.html#2892" class="Bound">x</a> <a id="2894" class="Symbol">=</a> <a id="2896" href="TypeTopology.CompactTypes.html#17424" class="Function">compact∙-types-are-closed-under-equiv</a><a id="2933" class="Symbol">(</a><a id="2934" href="UF.Equiv.html#7278" class="Function">≃-sym</a><a id="2939" class="Symbol">(</a><a id="2940" href="TypeTopology.PropTychonoff.html#2698" class="Function">hip</a> <a id="2944" href="TypeTopology.PropTychonoff.html#2892" class="Bound">x</a><a id="2945" class="Symbol">))</a> <a id="2948" class="Symbol">(</a><a id="2949" href="TypeTopology.PropTychonoff.html#2574" class="Bound">ε</a> <a id="2951" href="TypeTopology.PropTychonoff.html#2892" class="Bound">x</a><a id="2952" class="Symbol">)</a>

<a id="2955" class="Markup">\end{code}</a><a id="2965" class="Background">

But this is very crude for our purposes (or so it seems).  So we
instead proceed as follows.

The following is what we get from prop-indexed-product, abstractly:

</a><a id="3130" class="Markup">\begin{code}</a>

  <a id="3146" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="3148" class="Symbol">:</a> <a id="3150" class="Symbol">(</a><a id="3151" href="TypeTopology.PropTychonoff.html#3151" class="Bound">x</a> <a id="3153" class="Symbol">:</a> <a id="3155" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3156" class="Symbol">)</a> <a id="3158" class="Symbol">→</a> <a id="3160" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="3162" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="3164" class="Symbol">→</a> <a id="3166" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="3168" href="TypeTopology.PropTychonoff.html#3151" class="Bound">x</a>
  <a id="3172" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="3174" href="TypeTopology.PropTychonoff.html#3174" class="Bound">x</a> <a id="3176" class="Symbol">=</a> <a id="3178" href="MLTT.Sigma-Type.html#213" class="Field">pr₁</a> <a id="3182" class="Symbol">(</a><a id="3183" href="TypeTopology.PropTychonoff.html#2698" class="Function">hip</a> <a id="3187" href="TypeTopology.PropTychonoff.html#3174" class="Bound">x</a><a id="3188" class="Symbol">)</a>

  <a id="3193" href="TypeTopology.PropTychonoff.html#3193" class="Function">hrf</a> <a id="3197" class="Symbol">:</a> <a id="3199" class="Symbol">(</a><a id="3200" href="TypeTopology.PropTychonoff.html#3200" class="Bound">x</a> <a id="3202" class="Symbol">:</a> <a id="3204" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3205" class="Symbol">)</a> <a id="3207" class="Symbol">→</a> <a id="3209" href="MLTT.Sigma.html#437" class="Function">Σ</a> <a id="3211" href="TypeTopology.PropTychonoff.html#3211" class="Bound">r</a> <a id="3213" href="MLTT.Sigma.html#437" class="Function">꞉</a> <a id="3215" class="Symbol">(</a><a id="3216" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="3218" href="TypeTopology.PropTychonoff.html#3200" class="Bound">x</a> <a id="3220" class="Symbol">→</a> <a id="3222" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="3224" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="3225" class="Symbol">)</a><a id="3226" href="MLTT.Sigma.html#437" class="Function">,</a> <a id="3228" href="TypeTopology.PropTychonoff.html#3211" class="Bound">r</a> <a id="3230" href="MLTT.Pi.html#527" class="Function Operator">∘</a> <a id="3232" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="3234" href="TypeTopology.PropTychonoff.html#3200" class="Bound">x</a> <a id="3236" href="MLTT.Id.html#1382" class="Function Operator">∼</a> <a id="3238" href="MLTT.Pi.html#458" class="Function">id</a>
  <a id="3243" href="TypeTopology.PropTychonoff.html#3193" class="Function">hrf</a> <a id="3247" href="TypeTopology.PropTychonoff.html#3247" class="Bound">x</a> <a id="3249" class="Symbol">=</a> <a id="3251" href="MLTT.Sigma-Type.html#224" class="Field">pr₂</a> <a id="3255" class="Symbol">(</a><a id="3256" href="MLTT.Sigma-Type.html#224" class="Field">pr₂</a> <a id="3260" class="Symbol">(</a><a id="3261" href="TypeTopology.PropTychonoff.html#2698" class="Function">hip</a> <a id="3265" href="TypeTopology.PropTychonoff.html#3247" class="Bound">x</a><a id="3266" class="Symbol">))</a>

  <a id="3272" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="3274" class="Symbol">:</a> <a id="3276" class="Symbol">(</a><a id="3277" href="TypeTopology.PropTychonoff.html#3277" class="Bound">x</a> <a id="3279" class="Symbol">:</a> <a id="3281" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3282" class="Symbol">)</a> <a id="3284" class="Symbol">→</a> <a id="3286" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="3288" href="TypeTopology.PropTychonoff.html#3277" class="Bound">x</a> <a id="3290" class="Symbol">→</a> <a id="3292" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="3294" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a>
  <a id="3298" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="3300" href="TypeTopology.PropTychonoff.html#3300" class="Bound">x</a> <a id="3302" class="Symbol">=</a> <a id="3304" href="MLTT.Sigma-Type.html#213" class="Field">pr₁</a> <a id="3308" class="Symbol">(</a><a id="3309" href="TypeTopology.PropTychonoff.html#3193" class="Function">hrf</a> <a id="3313" href="TypeTopology.PropTychonoff.html#3300" class="Bound">x</a><a id="3314" class="Symbol">)</a>

  <a id="3319" href="TypeTopology.PropTychonoff.html#3319" class="Function">hf</a> <a id="3322" class="Symbol">:</a> <a id="3324" class="Symbol">(</a><a id="3325" href="TypeTopology.PropTychonoff.html#3325" class="Bound">x</a> <a id="3327" class="Symbol">:</a> <a id="3329" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3330" class="Symbol">)</a> <a id="3332" class="Symbol">(</a><a id="3333" href="TypeTopology.PropTychonoff.html#3333" class="Bound">φ</a> <a id="3335" class="Symbol">:</a> <a id="3337" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="3339" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="3340" class="Symbol">)</a> <a id="3342" class="Symbol">→</a> <a id="3344" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="3346" href="TypeTopology.PropTychonoff.html#3325" class="Bound">x</a> <a id="3348" class="Symbol">(</a><a id="3349" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="3351" href="TypeTopology.PropTychonoff.html#3325" class="Bound">x</a> <a id="3353" href="TypeTopology.PropTychonoff.html#3333" class="Bound">φ</a><a id="3354" class="Symbol">)</a> <a id="3356" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="3358" href="TypeTopology.PropTychonoff.html#3333" class="Bound">φ</a>
  <a id="3362" href="TypeTopology.PropTychonoff.html#3319" class="Function">hf</a> <a id="3365" href="TypeTopology.PropTychonoff.html#3365" class="Bound">x</a> <a id="3367" class="Symbol">=</a> <a id="3369" href="MLTT.Sigma-Type.html#224" class="Field">pr₂</a> <a id="3373" class="Symbol">(</a><a id="3374" href="TypeTopology.PropTychonoff.html#3193" class="Function">hrf</a> <a id="3378" href="TypeTopology.PropTychonoff.html#3365" class="Bound">x</a><a id="3379" class="Symbol">)</a>

<a id="3382" class="Markup">\end{code}</a><a id="3392" class="Background">

We define a predicate q x : Y x → 𝟚, for each x : X, from the
predicate p : Π Y → 𝟚 via (part of) the above equivalence:

</a><a id="3516" class="Markup">\begin{code}</a>

  <a id="3532" href="TypeTopology.PropTychonoff.html#3532" class="Function">q</a> <a id="3534" class="Symbol">:</a> <a id="3536" class="Symbol">(</a><a id="3537" href="TypeTopology.PropTychonoff.html#3537" class="Bound">x</a> <a id="3539" class="Symbol">:</a> <a id="3541" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3542" class="Symbol">)</a> <a id="3544" class="Symbol">→</a> <a id="3546" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="3548" href="TypeTopology.PropTychonoff.html#3537" class="Bound">x</a> <a id="3550" class="Symbol">→</a> <a id="3552" href="MLTT.Two.html#138" class="Datatype">𝟚</a>
  <a id="3556" href="TypeTopology.PropTychonoff.html#3532" class="Function">q</a> <a id="3558" href="TypeTopology.PropTychonoff.html#3558" class="Bound">x</a> <a id="3560" href="TypeTopology.PropTychonoff.html#3560" class="Bound">y</a> <a id="3562" class="Symbol">=</a> <a id="3564" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="3566" class="Symbol">(</a><a id="3567" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="3569" href="TypeTopology.PropTychonoff.html#3558" class="Bound">x</a> <a id="3571" href="TypeTopology.PropTychonoff.html#3560" class="Bound">y</a><a id="3572" class="Symbol">)</a>

<a id="3575" class="Markup">\end{code}</a><a id="3585" class="Background">

We argue that the following is a universal witness for the
searchability of the type Π Y wrt the predicate p:

</a><a id="3698" class="Markup">\begin{code}</a>

  <a id="3714" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="3717" class="Symbol">:</a> <a id="3719" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="3721" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a>
  <a id="3725" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="3728" href="TypeTopology.PropTychonoff.html#3728" class="Bound">x</a> <a id="3730" class="Symbol">=</a> <a id="3732" href="MLTT.Sigma-Type.html#213" class="Field">pr₁</a> <a id="3736" class="Symbol">(</a><a id="3737" href="TypeTopology.PropTychonoff.html#2574" class="Bound">ε</a> <a id="3739" href="TypeTopology.PropTychonoff.html#3728" class="Bound">x</a> <a id="3741" class="Symbol">(</a><a id="3742" href="TypeTopology.PropTychonoff.html#3532" class="Function">q</a> <a id="3744" href="TypeTopology.PropTychonoff.html#3728" class="Bound">x</a><a id="3745" class="Symbol">))</a>

<a id="3749" class="Markup">\end{code}</a><a id="3759" class="Background">

By hypothesis, it satisfies:

</a><a id="3791" class="Markup">\begin{code}</a>

  <a id="3807" href="TypeTopology.PropTychonoff.html#3807" class="Function">φ₀-spec</a> <a id="3815" class="Symbol">:</a> <a id="3817" class="Symbol">(</a><a id="3818" href="TypeTopology.PropTychonoff.html#3818" class="Bound">x</a> <a id="3820" class="Symbol">:</a> <a id="3822" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3823" class="Symbol">)</a> <a id="3825" class="Symbol">→</a> <a id="3827" href="TypeTopology.PropTychonoff.html#3532" class="Function">q</a> <a id="3829" href="TypeTopology.PropTychonoff.html#3818" class="Bound">x</a> <a id="3831" class="Symbol">(</a><a id="3832" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="3835" href="TypeTopology.PropTychonoff.html#3818" class="Bound">x</a><a id="3836" class="Symbol">)</a> <a id="3838" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="3840" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="3842" class="Symbol">→</a> <a id="3844" class="Symbol">(</a><a id="3845" href="TypeTopology.PropTychonoff.html#3845" class="Bound">y</a> <a id="3847" class="Symbol">:</a> <a id="3849" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="3851" href="TypeTopology.PropTychonoff.html#3818" class="Bound">x</a><a id="3852" class="Symbol">)</a> <a id="3854" class="Symbol">→</a> <a id="3856" href="TypeTopology.PropTychonoff.html#3532" class="Function">q</a> <a id="3858" href="TypeTopology.PropTychonoff.html#3818" class="Bound">x</a> <a id="3860" href="TypeTopology.PropTychonoff.html#3845" class="Bound">y</a> <a id="3862" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="3864" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="3868" href="TypeTopology.PropTychonoff.html#3807" class="Function">φ₀-spec</a> <a id="3876" href="TypeTopology.PropTychonoff.html#3876" class="Bound">x</a> <a id="3878" class="Symbol">=</a> <a id="3880" href="MLTT.Sigma-Type.html#224" class="Field">pr₂</a> <a id="3884" class="Symbol">(</a><a id="3885" href="TypeTopology.PropTychonoff.html#2574" class="Bound">ε</a> <a id="3887" href="TypeTopology.PropTychonoff.html#3876" class="Bound">x</a> <a id="3889" class="Symbol">(</a><a id="3890" href="TypeTopology.PropTychonoff.html#3532" class="Function">q</a> <a id="3892" href="TypeTopology.PropTychonoff.html#3876" class="Bound">x</a><a id="3893" class="Symbol">))</a>

<a id="3897" class="Markup">\end{code}</a><a id="3907" class="Background">

By expanding the definitions, this amounts to:

</a><a id="3957" class="Markup">\begin{code}</a>

  <a id="3973" href="TypeTopology.PropTychonoff.html#3973" class="Function">φ₀-spec₀</a> <a id="3982" class="Symbol">:</a> <a id="3984" class="Symbol">(</a><a id="3985" href="TypeTopology.PropTychonoff.html#3985" class="Bound">x</a> <a id="3987" class="Symbol">:</a> <a id="3989" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="3990" class="Symbol">)</a> <a id="3992" class="Symbol">→</a> <a id="3994" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="3996" class="Symbol">(</a><a id="3997" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="3999" href="TypeTopology.PropTychonoff.html#3985" class="Bound">x</a> <a id="4001" class="Symbol">(</a><a id="4002" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="4005" href="TypeTopology.PropTychonoff.html#3985" class="Bound">x</a><a id="4006" class="Symbol">))</a> <a id="4009" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4011" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="4013" class="Symbol">→</a> <a id="4015" class="Symbol">(</a><a id="4016" href="TypeTopology.PropTychonoff.html#4016" class="Bound">y</a> <a id="4018" class="Symbol">:</a> <a id="4020" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="4022" href="TypeTopology.PropTychonoff.html#3985" class="Bound">x</a><a id="4023" class="Symbol">)</a> <a id="4025" class="Symbol">→</a> <a id="4027" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4029" class="Symbol">(</a><a id="4030" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4032" href="TypeTopology.PropTychonoff.html#3985" class="Bound">x</a> <a id="4034" href="TypeTopology.PropTychonoff.html#4016" class="Bound">y</a><a id="4035" class="Symbol">)</a> <a id="4037" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4039" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="4043" href="TypeTopology.PropTychonoff.html#3973" class="Function">φ₀-spec₀</a> <a id="4052" class="Symbol">=</a> <a id="4054" href="TypeTopology.PropTychonoff.html#3807" class="Function">φ₀-spec</a>

<a id="4063" class="Markup">\end{code}</a><a id="4073" class="Background">

By the definition of f in prop-indexed-product (namely f x φ = φ x):

</a><a id="4145" class="Markup">\begin{code}</a>

  <a id="4161" href="TypeTopology.PropTychonoff.html#4161" class="Function">φ₀-spec₁</a> <a id="4170" class="Symbol">:</a> <a id="4172" class="Symbol">(</a><a id="4173" href="TypeTopology.PropTychonoff.html#4173" class="Bound">x</a> <a id="4175" class="Symbol">:</a> <a id="4177" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="4178" class="Symbol">)</a> <a id="4180" class="Symbol">→</a> <a id="4182" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4184" class="Symbol">(</a><a id="4185" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4187" href="TypeTopology.PropTychonoff.html#4173" class="Bound">x</a> <a id="4189" class="Symbol">(</a><a id="4190" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="4192" href="TypeTopology.PropTychonoff.html#4173" class="Bound">x</a> <a id="4194" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a><a id="4196" class="Symbol">))</a> <a id="4199" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4201" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="4203" class="Symbol">→</a> <a id="4205" class="Symbol">(</a><a id="4206" href="TypeTopology.PropTychonoff.html#4206" class="Bound">y</a> <a id="4208" class="Symbol">:</a> <a id="4210" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="4212" href="TypeTopology.PropTychonoff.html#4173" class="Bound">x</a><a id="4213" class="Symbol">)</a> <a id="4215" class="Symbol">→</a> <a id="4217" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4219" class="Symbol">(</a><a id="4220" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4222" href="TypeTopology.PropTychonoff.html#4173" class="Bound">x</a> <a id="4224" href="TypeTopology.PropTychonoff.html#4206" class="Bound">y</a><a id="4225" class="Symbol">)</a> <a id="4227" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4229" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="4233" href="TypeTopology.PropTychonoff.html#4161" class="Function">φ₀-spec₁</a> <a id="4242" class="Symbol">=</a> <a id="4244" href="TypeTopology.PropTychonoff.html#3973" class="Function">φ₀-spec₀</a>

<a id="4254" class="Markup">\end{code}</a><a id="4264" class="Background">

(So we can&#39;t abstract away the construction of prop-indexed-product.)

In particular, with y = f x φ, we get:

</a><a id="4377" class="Markup">\begin{code}</a>

  <a id="4393" href="TypeTopology.PropTychonoff.html#4393" class="Function">φ₀-spec₁-particular-case</a> <a id="4418" class="Symbol">:</a> <a id="4420" class="Symbol">(</a><a id="4421" href="TypeTopology.PropTychonoff.html#4421" class="Bound">x</a> <a id="4423" class="Symbol">:</a> <a id="4425" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a><a id="4426" class="Symbol">)</a>
                           <a id="4455" class="Symbol">→</a> <a id="4457" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4459" class="Symbol">(</a><a id="4460" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4462" href="TypeTopology.PropTychonoff.html#4421" class="Bound">x</a> <a id="4464" class="Symbol">(</a><a id="4465" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="4467" href="TypeTopology.PropTychonoff.html#4421" class="Bound">x</a> <a id="4469" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a><a id="4471" class="Symbol">))</a> <a id="4474" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4476" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
                           <a id="4505" class="Symbol">→</a> <a id="4507" class="Symbol">(</a><a id="4508" href="TypeTopology.PropTychonoff.html#4508" class="Bound">φ</a> <a id="4510" class="Symbol">:</a> <a id="4512" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="4514" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="4515" class="Symbol">)</a> <a id="4517" class="Symbol">→</a> <a id="4519" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4521" class="Symbol">(</a><a id="4522" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4524" href="TypeTopology.PropTychonoff.html#4421" class="Bound">x</a> <a id="4526" class="Symbol">(</a><a id="4527" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="4529" href="TypeTopology.PropTychonoff.html#4421" class="Bound">x</a> <a id="4531" href="TypeTopology.PropTychonoff.html#4508" class="Bound">φ</a><a id="4532" class="Symbol">))</a> <a id="4535" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4537" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="4541" href="TypeTopology.PropTychonoff.html#4393" class="Function">φ₀-spec₁-particular-case</a> <a id="4566" href="TypeTopology.PropTychonoff.html#4566" class="Bound">x</a> <a id="4568" href="TypeTopology.PropTychonoff.html#4568" class="Bound">r</a> <a id="4570" href="TypeTopology.PropTychonoff.html#4570" class="Bound">φ</a> <a id="4572" class="Symbol">=</a> <a id="4574" href="TypeTopology.PropTychonoff.html#4161" class="Function">φ₀-spec₁</a> <a id="4583" href="TypeTopology.PropTychonoff.html#4566" class="Bound">x</a> <a id="4585" href="TypeTopology.PropTychonoff.html#4568" class="Bound">r</a> <a id="4587" class="Symbol">(</a><a id="4588" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="4590" href="TypeTopology.PropTychonoff.html#4566" class="Bound">x</a> <a id="4592" href="TypeTopology.PropTychonoff.html#4570" class="Bound">φ</a><a id="4593" class="Symbol">)</a>

<a id="4596" class="Markup">\end{code}</a><a id="4606" class="Background">

Using the fact that g x (f x φ) = φ for any x:X, we get:

</a><a id="4666" class="Markup">\begin{code}</a>

  <a id="4682" href="TypeTopology.PropTychonoff.html#4682" class="Function">φ₀-is-universal-witness-assuming-X</a> <a id="4717" class="Symbol">:</a> <a id="4719" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a> <a id="4721" class="Symbol">→</a> <a id="4723" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4725" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="4728" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4730" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="4732" class="Symbol">→</a> <a id="4734" class="Symbol">(</a><a id="4735" href="TypeTopology.PropTychonoff.html#4735" class="Bound">φ</a> <a id="4737" class="Symbol">:</a> <a id="4739" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="4741" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="4742" class="Symbol">)</a> <a id="4744" class="Symbol">→</a> <a id="4746" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4748" href="TypeTopology.PropTychonoff.html#4735" class="Bound">φ</a> <a id="4750" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="4752" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="4756" href="TypeTopology.PropTychonoff.html#4682" class="Function">φ₀-is-universal-witness-assuming-X</a> <a id="4791" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4793" href="TypeTopology.PropTychonoff.html#4793" class="Bound">r</a> <a id="4795" href="TypeTopology.PropTychonoff.html#4795" class="Bound">φ</a> <a id="4797" class="Symbol">=</a>
     <a id="4804" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4806" href="TypeTopology.PropTychonoff.html#4795" class="Bound">φ</a>             <a id="4820" href="MLTT.Id.html#1942" class="Function Operator">＝⟨</a> <a id="4823" href="MLTT.Id.html#1151" class="Function">ap</a> <a id="4826" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4828" class="Symbol">((</a><a id="4830" href="TypeTopology.PropTychonoff.html#3319" class="Function">hf</a> <a id="4833" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4835" href="TypeTopology.PropTychonoff.html#4795" class="Bound">φ</a><a id="4836" class="Symbol">)</a><a id="4837" href="MLTT.Id.html#1070" class="Function Operator">⁻¹</a><a id="4839" class="Symbol">)</a> <a id="4841" href="MLTT.Id.html#1942" class="Function Operator">⟩</a>
     <a id="4848" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4850" class="Symbol">(</a><a id="4851" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4853" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4855" class="Symbol">(</a><a id="4856" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="4858" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4860" href="TypeTopology.PropTychonoff.html#4795" class="Bound">φ</a><a id="4861" class="Symbol">))</a> <a id="4864" href="MLTT.Id.html#1942" class="Function Operator">＝⟨</a> <a id="4867" href="TypeTopology.PropTychonoff.html#4393" class="Function">φ₀-spec₁-particular-case</a> <a id="4892" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4894" href="TypeTopology.PropTychonoff.html#4936" class="Function">s</a> <a id="4896" href="TypeTopology.PropTychonoff.html#4795" class="Bound">φ</a> <a id="4898" href="MLTT.Id.html#1942" class="Function Operator">⟩</a>
     <a id="4905" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>               <a id="4921" href="MLTT.Id.html#2024" class="Function Operator">∎</a>
   <a id="4926" class="Keyword">where</a>
    <a id="4936" href="TypeTopology.PropTychonoff.html#4936" class="Function">s</a> <a id="4938" class="Symbol">=</a> <a id="4940" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4942" class="Symbol">(</a><a id="4943" href="TypeTopology.PropTychonoff.html#3272" class="Function">h</a> <a id="4945" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4947" class="Symbol">(</a><a id="4948" href="TypeTopology.PropTychonoff.html#3146" class="Function">f</a> <a id="4950" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4952" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a><a id="4954" class="Symbol">))</a> <a id="4957" href="MLTT.Id.html#1942" class="Function Operator">＝⟨</a> <a id="4960" href="MLTT.Id.html#1151" class="Function">ap</a> <a id="4963" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4965" class="Symbol">(</a><a id="4966" href="TypeTopology.PropTychonoff.html#3319" class="Function">hf</a> <a id="4969" href="TypeTopology.PropTychonoff.html#4791" class="Bound">x</a> <a id="4971" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a><a id="4973" class="Symbol">)</a> <a id="4975" href="MLTT.Id.html#1942" class="Function Operator">⟩</a>
        <a id="4985" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="4987" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a>             <a id="5002" href="MLTT.Id.html#1942" class="Function Operator">＝⟨</a> <a id="5005" href="TypeTopology.PropTychonoff.html#4793" class="Bound">r</a> <a id="5007" href="MLTT.Id.html#1942" class="Function Operator">⟩</a>
        <a id="5017" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>                <a id="5034" href="MLTT.Id.html#2024" class="Function Operator">∎</a>

<a id="5037" class="Markup">\end{code}</a><a id="5047" class="Background">

Notice that the point x : X vanishes from the conclusion, and so we
are able to omit it from the hypothesis, which is crucial for what
follows.

We get the same conclusion if X is empty:

</a><a id="5237" class="Markup">\begin{code}</a>

  <a id="5253" href="TypeTopology.PropTychonoff.html#5253" class="Function">φ₀-is-universal-witness-assuming-X→𝟘</a> <a id="5290" class="Symbol">:</a> <a id="5292" class="Symbol">(</a><a id="5293" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a> <a id="5295" class="Symbol">→</a> <a id="5297" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a><a id="5298" class="Symbol">)</a> <a id="5300" class="Symbol">→</a> <a id="5302" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5304" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="5307" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="5309" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="5311" class="Symbol">→</a> <a id="5313" class="Symbol">(</a><a id="5314" href="TypeTopology.PropTychonoff.html#5314" class="Bound">φ</a> <a id="5316" class="Symbol">:</a> <a id="5318" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="5320" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="5321" class="Symbol">)</a> <a id="5323" class="Symbol">→</a> <a id="5325" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5327" href="TypeTopology.PropTychonoff.html#5314" class="Bound">φ</a> <a id="5329" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="5331" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="5335" href="TypeTopology.PropTychonoff.html#5253" class="Function">φ₀-is-universal-witness-assuming-X→𝟘</a> <a id="5372" href="TypeTopology.PropTychonoff.html#5372" class="Bound">u</a> <a id="5374" href="TypeTopology.PropTychonoff.html#5374" class="Bound">r</a> <a id="5376" href="TypeTopology.PropTychonoff.html#5376" class="Bound">φ</a> <a id="5378" class="Symbol">=</a> <a id="5380" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5382" href="TypeTopology.PropTychonoff.html#5376" class="Bound">φ</a>  <a id="5385" href="MLTT.Id.html#1942" class="Function Operator">＝⟨</a> <a id="5388" href="MLTT.Id.html#1151" class="Function">ap</a> <a id="5391" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5393" href="TypeTopology.PropTychonoff.html#5528" class="Function">claim</a> <a id="5399" href="MLTT.Id.html#1942" class="Function Operator">⟩</a>
                                               <a id="5448" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5450" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="5453" href="MLTT.Id.html#1942" class="Function Operator">＝⟨</a> <a id="5456" href="TypeTopology.PropTychonoff.html#5374" class="Bound">r</a> <a id="5458" href="MLTT.Id.html#1942" class="Function Operator">⟩</a>
                                               <a id="5507" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>    <a id="5512" href="MLTT.Id.html#2024" class="Function Operator">∎</a>

   <a id="5518" class="Keyword">where</a>
    <a id="5528" href="TypeTopology.PropTychonoff.html#5528" class="Function">claim</a> <a id="5534" class="Symbol">:</a> <a id="5536" href="TypeTopology.PropTychonoff.html#5376" class="Bound">φ</a> <a id="5538" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="5540" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a>
    <a id="5547" href="TypeTopology.PropTychonoff.html#5528" class="Function">claim</a> <a id="5553" class="Symbol">=</a> <a id="5555" href="UF.FunExt.html#1217" class="Function">dfunext</a> <a id="5563" class="Symbol">(</a><a id="5564" href="TypeTopology.PropTychonoff.html#1493" class="Bound">fe</a> <a id="5567" href="TypeTopology.PropTychonoff.html#2549" class="Bound">𝓤</a> <a id="5569" href="TypeTopology.PropTychonoff.html#2553" class="Bound">𝓥</a><a id="5570" class="Symbol">)</a> <a id="5572" class="Symbol">(λ</a> <a id="5575" href="TypeTopology.PropTychonoff.html#5575" class="Bound">x</a> <a id="5577" class="Symbol">→</a> <a id="5579" href="MLTT.Empty.html#302" class="Function">unique-from-𝟘</a> <a id="5593" class="Symbol">(</a><a id="5594" href="TypeTopology.PropTychonoff.html#5372" class="Bound">u</a> <a id="5596" href="TypeTopology.PropTychonoff.html#5575" class="Bound">x</a><a id="5597" class="Symbol">))</a>

<a id="5601" class="Markup">\end{code}</a><a id="5611" class="Background">

So we would get what we want if we had excluded middle, because X is a
proposition and the above shows that both X and X → 𝟘 give the desired
conclusion that φ₀ is a universal witness. But excluded middle is not
needed.

We shuffle the arguments of φ₀-is-universal-witness-assuming-X:

</a><a id="5899" class="Markup">\begin{code}</a>
  <a id="5914" href="TypeTopology.PropTychonoff.html#5914" class="Function">claim₀</a> <a id="5921" class="Symbol">:</a> <a id="5923" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5925" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="5928" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="5930" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="5932" class="Symbol">→</a> <a id="5934" class="Symbol">(</a><a id="5935" href="TypeTopology.PropTychonoff.html#5935" class="Bound">φ</a> <a id="5937" class="Symbol">:</a> <a id="5939" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="5941" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="5942" class="Symbol">)</a> <a id="5944" class="Symbol">→</a> <a id="5946" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a> <a id="5948" class="Symbol">→</a> <a id="5950" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="5952" href="TypeTopology.PropTychonoff.html#5935" class="Bound">φ</a> <a id="5954" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="5956" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="5960" href="TypeTopology.PropTychonoff.html#5914" class="Function">claim₀</a> <a id="5967" href="TypeTopology.PropTychonoff.html#5967" class="Bound">r</a> <a id="5969" href="TypeTopology.PropTychonoff.html#5969" class="Bound">φ</a> <a id="5971" href="TypeTopology.PropTychonoff.html#5971" class="Bound">x</a> <a id="5973" class="Symbol">=</a> <a id="5975" href="TypeTopology.PropTychonoff.html#4682" class="Function">φ₀-is-universal-witness-assuming-X</a> <a id="6010" href="TypeTopology.PropTychonoff.html#5971" class="Bound">x</a> <a id="6012" href="TypeTopology.PropTychonoff.html#5967" class="Bound">r</a> <a id="6014" href="TypeTopology.PropTychonoff.html#5969" class="Bound">φ</a>

<a id="6017" class="Markup">\end{code}</a><a id="6027" class="Background">

We then take the contrapositive of the conclusion X → p φ ＝ ₁, and
use the fact that if a point of the two-point type 𝟚 is ₀, then it is
not ₁:

</a><a id="6174" class="Markup">\begin{code}</a>

  <a id="6190" href="TypeTopology.PropTychonoff.html#6190" class="Function">Claim₁</a> <a id="6197" class="Symbol">:</a> <a id="6199" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6201" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="6204" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6206" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="6208" class="Symbol">→</a> <a id="6210" class="Symbol">(</a><a id="6211" href="TypeTopology.PropTychonoff.html#6211" class="Bound">φ</a> <a id="6213" class="Symbol">:</a> <a id="6215" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="6217" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="6218" class="Symbol">)</a> <a id="6220" class="Symbol">→</a> <a id="6222" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6224" href="TypeTopology.PropTychonoff.html#6211" class="Bound">φ</a> <a id="6226" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6228" href="MLTT.Two.html#154" class="InductiveConstructor">₀</a> <a id="6230" class="Symbol">→</a> <a id="6232" class="Symbol">(</a><a id="6233" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a> <a id="6235" class="Symbol">→</a> <a id="6237" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a><a id="6238" class="Symbol">)</a>
  <a id="6242" href="TypeTopology.PropTychonoff.html#6190" class="Function">Claim₁</a> <a id="6249" href="TypeTopology.PropTychonoff.html#6249" class="Bound">r</a> <a id="6251" href="TypeTopology.PropTychonoff.html#6251" class="Bound">φ</a> <a id="6253" class="Symbol">=</a> <a id="6255" href="MLTT.Negation.html#1253" class="Function">contrapositive</a><a id="6269" class="Symbol">(</a><a id="6270" href="TypeTopology.PropTychonoff.html#5914" class="Function">claim₀</a> <a id="6277" href="TypeTopology.PropTychonoff.html#6249" class="Bound">r</a> <a id="6279" href="TypeTopology.PropTychonoff.html#6251" class="Bound">φ</a><a id="6280" class="Symbol">)</a> <a id="6282" href="MLTT.Pi.html#527" class="Function Operator">∘</a> <a id="6284" href="MLTT.Two-Properties.html#2571" class="Function">equal-₀-different-from-₁</a>

<a id="6310" class="Markup">\end{code}</a><a id="6320" class="Background">

This concludes the first part of the argument.

We now shuffle the arguments of φ₀-is-universal-witness-assuming-X→𝟘:

</a><a id="6441" class="Markup">\begin{code}</a>

  <a id="6457" href="TypeTopology.PropTychonoff.html#6457" class="Function">Claim₂</a> <a id="6464" class="Symbol">:</a> <a id="6466" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6468" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="6471" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6473" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="6475" class="Symbol">→</a> <a id="6477" class="Symbol">(</a><a id="6478" href="TypeTopology.PropTychonoff.html#6478" class="Bound">φ</a> <a id="6480" class="Symbol">:</a> <a id="6482" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="6484" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="6485" class="Symbol">)</a> <a id="6487" class="Symbol">→</a> <a id="6489" class="Symbol">(</a><a id="6490" href="TypeTopology.PropTychonoff.html#2557" class="Bound">X</a> <a id="6492" class="Symbol">→</a> <a id="6494" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a><a id="6495" class="Symbol">)</a> <a id="6497" class="Symbol">→</a> <a id="6499" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6501" href="TypeTopology.PropTychonoff.html#6478" class="Bound">φ</a> <a id="6503" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6505" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="6509" href="TypeTopology.PropTychonoff.html#6457" class="Function">Claim₂</a> <a id="6516" href="TypeTopology.PropTychonoff.html#6516" class="Bound">r</a> <a id="6518" href="TypeTopology.PropTychonoff.html#6518" class="Bound">φ</a> <a id="6520" href="TypeTopology.PropTychonoff.html#6520" class="Bound">u</a> <a id="6522" class="Symbol">=</a> <a id="6524" href="TypeTopology.PropTychonoff.html#5253" class="Function">φ₀-is-universal-witness-assuming-X→𝟘</a> <a id="6561" href="TypeTopology.PropTychonoff.html#6520" class="Bound">u</a> <a id="6563" href="TypeTopology.PropTychonoff.html#6516" class="Bound">r</a> <a id="6565" href="TypeTopology.PropTychonoff.html#6518" class="Bound">φ</a>

<a id="6568" class="Markup">\end{code}</a><a id="6578" class="Background">

Combining the two last claims, we get:

</a><a id="6620" class="Markup">\begin{code}</a>

  <a id="6636" href="TypeTopology.PropTychonoff.html#6636" class="Function">Claim₃</a> <a id="6643" class="Symbol">:</a> <a id="6645" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6647" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="6650" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6652" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="6654" class="Symbol">→</a> <a id="6656" class="Symbol">(</a><a id="6657" href="TypeTopology.PropTychonoff.html#6657" class="Bound">φ</a> <a id="6659" class="Symbol">:</a> <a id="6661" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="6663" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="6664" class="Symbol">)</a> <a id="6666" class="Symbol">→</a> <a id="6668" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6670" href="TypeTopology.PropTychonoff.html#6657" class="Bound">φ</a> <a id="6672" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6674" href="MLTT.Two.html#154" class="InductiveConstructor">₀</a> <a id="6676" class="Symbol">→</a> <a id="6678" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6680" href="TypeTopology.PropTychonoff.html#6657" class="Bound">φ</a> <a id="6682" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6684" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="6688" href="TypeTopology.PropTychonoff.html#6636" class="Function">Claim₃</a> <a id="6695" href="TypeTopology.PropTychonoff.html#6695" class="Bound">r</a> <a id="6697" href="TypeTopology.PropTychonoff.html#6697" class="Bound">φ</a> <a id="6699" class="Symbol">=</a> <a id="6701" href="TypeTopology.PropTychonoff.html#6457" class="Function">Claim₂</a> <a id="6708" href="TypeTopology.PropTychonoff.html#6695" class="Bound">r</a> <a id="6710" href="TypeTopology.PropTychonoff.html#6697" class="Bound">φ</a> <a id="6712" href="MLTT.Pi.html#527" class="Function Operator">∘</a> <a id="6714" href="TypeTopology.PropTychonoff.html#6190" class="Function">Claim₁</a> <a id="6721" href="TypeTopology.PropTychonoff.html#6695" class="Bound">r</a> <a id="6723" href="TypeTopology.PropTychonoff.html#6697" class="Bound">φ</a>

<a id="6726" class="Markup">\end{code}</a><a id="6736" class="Background">

Finally, we do case analysis on the value of p φ:

</a><a id="6789" class="Markup">\begin{code}</a>

  <a id="6805" href="TypeTopology.PropTychonoff.html#6805" class="Function">φ₀-is-universal-witness</a> <a id="6829" class="Symbol">:</a> <a id="6831" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6833" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="6836" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6838" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="6840" class="Symbol">→</a> <a id="6842" class="Symbol">(</a><a id="6843" href="TypeTopology.PropTychonoff.html#6843" class="Bound">φ</a> <a id="6845" class="Symbol">:</a> <a id="6847" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="6849" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="6850" class="Symbol">)</a> <a id="6852" class="Symbol">→</a> <a id="6854" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6856" href="TypeTopology.PropTychonoff.html#6843" class="Bound">φ</a> <a id="6858" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6860" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a>
  <a id="6864" href="TypeTopology.PropTychonoff.html#6805" class="Function">φ₀-is-universal-witness</a> <a id="6888" href="TypeTopology.PropTychonoff.html#6888" class="Bound">r</a> <a id="6890" href="TypeTopology.PropTychonoff.html#6890" class="Bound">φ</a> <a id="6892" class="Symbol">=</a> <a id="6894" href="MLTT.Two-Properties.html#437" class="Function">𝟚-equality-cases</a> <a id="6911" class="Symbol">(</a><a id="6912" href="TypeTopology.PropTychonoff.html#6636" class="Function">Claim₃</a> <a id="6919" href="TypeTopology.PropTychonoff.html#6888" class="Bound">r</a> <a id="6921" href="TypeTopology.PropTychonoff.html#6890" class="Bound">φ</a><a id="6922" class="Symbol">)</a> <a id="6924" href="MLTT.Pi.html#458" class="Function">id</a>

<a id="6928" class="Markup">\end{code}</a><a id="6938" class="Background">

And we are done:

</a><a id="6958" class="Markup">\begin{code}</a>

  <a id="6974" href="TypeTopology.PropTychonoff.html#6974" class="Function">γ</a> <a id="6976" class="Symbol">:</a> <a id="6978" href="MLTT.Sigma.html#437" class="Function">Σ</a> <a id="6980" href="TypeTopology.PropTychonoff.html#6980" class="Bound">φ₀</a> <a id="6983" href="MLTT.Sigma.html#437" class="Function">꞉</a> <a id="6985" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="6987" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a> <a id="6989" href="MLTT.Sigma.html#437" class="Function">,</a> <a id="6991" class="Symbol">(</a><a id="6992" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="6994" href="TypeTopology.PropTychonoff.html#6980" class="Bound">φ₀</a> <a id="6997" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="6999" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a> <a id="7001" class="Symbol">→</a> <a id="7003" class="Symbol">(</a><a id="7004" href="TypeTopology.PropTychonoff.html#7004" class="Bound">φ</a> <a id="7006" class="Symbol">:</a> <a id="7008" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="7010" href="TypeTopology.PropTychonoff.html#2561" class="Bound">Y</a><a id="7011" class="Symbol">)</a> <a id="7013" class="Symbol">→</a> <a id="7015" href="TypeTopology.PropTychonoff.html#2576" class="Bound">p</a> <a id="7017" href="TypeTopology.PropTychonoff.html#7004" class="Bound">φ</a> <a id="7019" href="MLTT.Id.html#207" class="Datatype Operator">＝</a> <a id="7021" href="MLTT.Two.html#161" class="InductiveConstructor">₁</a><a id="7022" class="Symbol">)</a>
  <a id="7026" href="TypeTopology.PropTychonoff.html#6974" class="Function">γ</a> <a id="7028" class="Symbol">=</a> <a id="7030" href="TypeTopology.PropTychonoff.html#3714" class="Function">φ₀</a> <a id="7033" href="MLTT.Sigma.html#409" class="InductiveConstructor Operator">,</a> <a id="7035" href="TypeTopology.PropTychonoff.html#6805" class="Function">φ₀-is-universal-witness</a>

<a id="7060" class="Markup">\end{code}</a><a id="7070" class="Background">


TODO. 9 Sep 2015. We can generalize from X being a subsingleton (or
proposition) to X being subfinite (embedded into a finite type).

A particular case is the following:

</a><a id="7244" class="Markup">\begin{code}</a>

<a id="prop-tychonoff-corollary"></a><a id="7258" href="TypeTopology.PropTychonoff.html#7258" class="Function">prop-tychonoff-corollary</a> <a id="7283" class="Symbol">:</a> <a id="7285" class="Symbol">{</a><a id="7286" href="TypeTopology.PropTychonoff.html#7286" class="Bound">X</a> <a id="7288" class="Symbol">:</a> <a id="7290" href="MLTT.Universes.html#265" class="Generalizable">𝓤</a> <a id="7292" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="7294" class="Symbol">}</a> <a id="7296" class="Symbol">{</a><a id="7297" href="TypeTopology.PropTychonoff.html#7297" class="Bound">Y</a> <a id="7299" class="Symbol">:</a> <a id="7301" href="MLTT.Universes.html#267" class="Generalizable">𝓥</a> <a id="7303" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="7305" class="Symbol">}</a>
                         <a id="7332" class="Symbol">→</a> <a id="7334" href="UF.Subsingletons.html#484" class="Function">is-prop</a> <a id="7342" href="TypeTopology.PropTychonoff.html#7286" class="Bound">X</a>
                         <a id="7369" class="Symbol">→</a> <a id="7371" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="7383" href="TypeTopology.PropTychonoff.html#7297" class="Bound">Y</a>
                         <a id="7410" class="Symbol">→</a> <a id="7412" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="7424" class="Symbol">(</a><a id="7425" href="TypeTopology.PropTychonoff.html#7286" class="Bound">X</a> <a id="7427" class="Symbol">→</a> <a id="7429" href="TypeTopology.PropTychonoff.html#7297" class="Bound">Y</a><a id="7430" class="Symbol">)</a>
<a id="7432" href="TypeTopology.PropTychonoff.html#7258" class="Function">prop-tychonoff-corollary</a> <a id="7457" href="TypeTopology.PropTychonoff.html#7457" class="Bound">X-is-prop</a> <a id="7467" href="TypeTopology.PropTychonoff.html#7467" class="Bound">ε</a> <a id="7469" class="Symbol">=</a> <a id="7471" href="TypeTopology.PropTychonoff.html#2381" class="Function">prop-tychonoff</a> <a id="7486" href="TypeTopology.PropTychonoff.html#7457" class="Bound">X-is-prop</a> <a id="7496" class="Symbol">(λ</a> <a id="7499" href="TypeTopology.PropTychonoff.html#7499" class="Bound">x</a> <a id="7501" class="Symbol">→</a> <a id="7503" href="TypeTopology.PropTychonoff.html#7467" class="Bound">ε</a><a id="7504" class="Symbol">)</a>

<a id="7507" class="Markup">\end{code}</a><a id="7517" class="Background">

This holds even for undecided X (such as X = LPO), or when we have no
idea whether X or (X → 𝟘), and hence whether (X → Y) is 𝟙 or Y (or
none, if this is undecided)!

Better (9 Sep 2015):

</a><a id="7708" class="Markup">\begin{code}</a>

<a id="prop-tychonoff-corollary&#39;"></a><a id="7722" href="TypeTopology.PropTychonoff.html#7722" class="Function">prop-tychonoff-corollary&#39;</a> <a id="7748" class="Symbol">:</a> <a id="7750" class="Symbol">{</a><a id="7751" href="TypeTopology.PropTychonoff.html#7751" class="Bound">X</a> <a id="7753" class="Symbol">:</a> <a id="7755" href="MLTT.Universes.html#265" class="Generalizable">𝓤</a> <a id="7757" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="7759" class="Symbol">}</a> <a id="7761" class="Symbol">{</a><a id="7762" href="TypeTopology.PropTychonoff.html#7762" class="Bound">Y</a> <a id="7764" class="Symbol">:</a> <a id="7766" href="MLTT.Universes.html#267" class="Generalizable">𝓥</a> <a id="7768" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="7770" class="Symbol">}</a>
                          <a id="7798" class="Symbol">→</a> <a id="7800" href="UF.Subsingletons.html#484" class="Function">is-prop</a> <a id="7808" href="TypeTopology.PropTychonoff.html#7751" class="Bound">X</a>
                          <a id="7836" class="Symbol">→</a> <a id="7838" class="Symbol">(</a><a id="7839" href="TypeTopology.PropTychonoff.html#7751" class="Bound">X</a> <a id="7841" class="Symbol">→</a> <a id="7843" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="7855" href="TypeTopology.PropTychonoff.html#7762" class="Bound">Y</a><a id="7856" class="Symbol">)</a>
                          <a id="7884" class="Symbol">→</a> <a id="7886" href="TypeTopology.CompactTypes.html#4346" class="Function">is-compact∙</a> <a id="7898" class="Symbol">(</a><a id="7899" href="TypeTopology.PropTychonoff.html#7751" class="Bound">X</a> <a id="7901" class="Symbol">→</a> <a id="7903" href="TypeTopology.PropTychonoff.html#7762" class="Bound">Y</a><a id="7904" class="Symbol">)</a>
<a id="7906" href="TypeTopology.PropTychonoff.html#7722" class="Function">prop-tychonoff-corollary&#39;</a> <a id="7932" class="Symbol">=</a> <a id="7934" href="TypeTopology.PropTychonoff.html#2381" class="Function">prop-tychonoff</a>

<a id="7950" class="Markup">\end{code}</a><a id="7960" class="Background">

So the function type (LPO → ℕ) is compact! (See the module LPO for a
proof.)

The Tychonoff theorem for prop-indexed products of compact types
doesn&#39;t hold. To see this, first notice that a proposition is
compact iff it is decidable. Now, the empty type 𝟘 is compact
(but not compact‌∙), and if 𝟘^P, that is, ¬P, where compact for a
proposition P, this would imply that ¬P is decidable for every
proposition P, which is weak excluded middle, which is not provable.

</a><a id="8428" class="Markup">\begin{code}</a>

<a id="8442" class="Keyword">open</a> <a id="8447" class="Keyword">import</a> <a id="8454" href="UF.ExcludedMiddle.html" class="Module">UF.ExcludedMiddle</a>

<a id="compact-prop-tychonoff-gives-WEM"></a><a id="8473" href="TypeTopology.PropTychonoff.html#8473" class="Function">compact-prop-tychonoff-gives-WEM</a> <a id="8506" class="Symbol">:</a> <a id="8508" class="Symbol">((</a><a id="8510" href="TypeTopology.PropTychonoff.html#8510" class="Bound">X</a> <a id="8512" class="Symbol">:</a> <a id="8514" href="MLTT.Universes.html#265" class="Generalizable">𝓤</a> <a id="8516" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="8518" class="Symbol">)</a> <a id="8520" class="Symbol">(</a><a id="8521" href="TypeTopology.PropTychonoff.html#8521" class="Bound">Y</a> <a id="8523" class="Symbol">:</a> <a id="8525" href="TypeTopology.PropTychonoff.html#8510" class="Bound">X</a> <a id="8527" class="Symbol">→</a> <a id="8529" href="MLTT.Universes.html#267" class="Generalizable">𝓥</a> <a id="8531" href="MLTT.Universes.html#408" class="Function Operator">̇</a> <a id="8533" class="Symbol">)</a>
                                       <a id="8574" class="Symbol">→</a> <a id="8576" href="UF.Subsingletons.html#484" class="Function">is-prop</a> <a id="8584" href="TypeTopology.PropTychonoff.html#8510" class="Bound">X</a>
                                       <a id="8625" class="Symbol">→</a> <a id="8627" class="Symbol">((</a><a id="8629" href="TypeTopology.PropTychonoff.html#8629" class="Bound">x</a> <a id="8631" class="Symbol">:</a> <a id="8633" href="TypeTopology.PropTychonoff.html#8510" class="Bound">X</a><a id="8634" class="Symbol">)</a> <a id="8636" class="Symbol">→</a> <a id="8638" href="TypeTopology.CompactTypes.html#3927" class="Function">is-compact</a> <a id="8649" class="Symbol">(</a><a id="8650" href="TypeTopology.PropTychonoff.html#8521" class="Bound">Y</a> <a id="8652" href="TypeTopology.PropTychonoff.html#8629" class="Bound">x</a><a id="8653" class="Symbol">))</a>
                                       <a id="8695" class="Symbol">→</a> <a id="8697" href="TypeTopology.CompactTypes.html#3927" class="Function">is-compact</a> <a id="8708" class="Symbol">(</a><a id="8709" href="MLTT.Pi.html#178" class="Function">Π</a> <a id="8711" href="TypeTopology.PropTychonoff.html#8521" class="Bound">Y</a><a id="8712" class="Symbol">))</a>
                                 <a id="8748" class="Symbol">→</a> <a id="8750" href="UF.ExcludedMiddle.html#1800" class="Function">WEM</a> <a id="8754" href="MLTT.Universes.html#265" class="Generalizable">𝓤</a>
<a id="8756" href="TypeTopology.PropTychonoff.html#8473" class="Function">compact-prop-tychonoff-gives-WEM</a> <a id="8789" class="Symbol">{</a><a id="8790" href="TypeTopology.PropTychonoff.html#8790" class="Bound">𝓤</a><a id="8791" class="Symbol">}</a> <a id="8793" class="Symbol">{</a><a id="8794" href="TypeTopology.PropTychonoff.html#8794" class="Bound">𝓥</a><a id="8795" class="Symbol">}</a> <a id="8797" href="TypeTopology.PropTychonoff.html#8797" class="Bound">τ</a> <a id="8799" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="8801" href="TypeTopology.PropTychonoff.html#8801" class="Bound">X-is-prop</a> <a id="8811" class="Symbol">=</a> <a id="8813" href="TypeTopology.PropTychonoff.html#9042" class="Function">δ</a> <a id="8815" href="TypeTopology.PropTychonoff.html#8951" class="Function">γ</a>
 <a id="8818" class="Keyword">where</a>
  <a id="8826" href="TypeTopology.PropTychonoff.html#8826" class="Function">Y</a> <a id="8828" class="Symbol">:</a> <a id="8830" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="8832" class="Symbol">→</a> <a id="8834" href="TypeTopology.PropTychonoff.html#8794" class="Bound">𝓥</a> <a id="8836" href="MLTT.Universes.html#408" class="Function Operator">̇</a>
  <a id="8840" href="TypeTopology.PropTychonoff.html#8826" class="Function">Y</a> <a id="8842" href="TypeTopology.PropTychonoff.html#8842" class="Bound">x</a> <a id="8844" class="Symbol">=</a> <a id="8846" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a>

  <a id="8851" href="TypeTopology.PropTychonoff.html#8851" class="Function">negation-compact</a> <a id="8868" class="Symbol">:</a> <a id="8870" href="TypeTopology.CompactTypes.html#3927" class="Function">is-compact</a> <a id="8881" class="Symbol">(</a><a id="8882" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="8884" class="Symbol">→</a> <a id="8886" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a> <a id="8888" class="Symbol">{</a><a id="8889" href="TypeTopology.PropTychonoff.html#8794" class="Bound">𝓥</a><a id="8890" class="Symbol">})</a>
  <a id="8895" href="TypeTopology.PropTychonoff.html#8851" class="Function">negation-compact</a> <a id="8912" class="Symbol">=</a> <a id="8914" href="TypeTopology.PropTychonoff.html#8797" class="Bound">τ</a> <a id="8916" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="8918" href="TypeTopology.PropTychonoff.html#8826" class="Function">Y</a> <a id="8920" href="TypeTopology.PropTychonoff.html#8801" class="Bound">X-is-prop</a> <a id="8930" class="Symbol">(λ</a> <a id="8933" href="TypeTopology.PropTychonoff.html#8933" class="Bound">p</a> <a id="8935" class="Symbol">→</a> <a id="8937" href="TypeTopology.CompactTypes.html#12044" class="Function">𝟘-compact</a><a id="8946" class="Symbol">)</a>

  <a id="8951" href="TypeTopology.PropTychonoff.html#8951" class="Function">γ</a> <a id="8953" class="Symbol">:</a> <a id="8955" href="MLTT.Negation.html#625" class="Function">is-decidable</a> <a id="8968" class="Symbol">(</a><a id="8969" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="8971" class="Symbol">→</a> <a id="8973" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a> <a id="8975" class="Symbol">{</a><a id="8976" href="TypeTopology.PropTychonoff.html#8794" class="Bound">𝓥</a><a id="8977" class="Symbol">})</a>
  <a id="8982" href="TypeTopology.PropTychonoff.html#8951" class="Function">γ</a> <a id="8984" class="Symbol">=</a> <a id="8986" href="TypeTopology.CompactTypes.html#12124" class="Function">compact-types-are-decidable</a> <a id="9014" class="Symbol">(</a><a id="9015" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="9017" class="Symbol">→</a> <a id="9019" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a><a id="9020" class="Symbol">)</a> <a id="9022" href="TypeTopology.PropTychonoff.html#8851" class="Function">negation-compact</a>

  <a id="9042" href="TypeTopology.PropTychonoff.html#9042" class="Function">δ</a> <a id="9044" class="Symbol">:</a> <a id="9046" href="MLTT.Negation.html#625" class="Function">is-decidable</a> <a id="9059" class="Symbol">(</a><a id="9060" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a> <a id="9062" class="Symbol">→</a> <a id="9064" href="MLTT.Empty-Type.html#135" class="Datatype">𝟘</a> <a id="9066" class="Symbol">{</a><a id="9067" href="TypeTopology.PropTychonoff.html#8794" class="Bound">𝓥</a><a id="9068" class="Symbol">})</a> <a id="9071" class="Symbol">→</a> <a id="9073" href="MLTT.Negation.html#625" class="Function">is-decidable</a> <a id="9086" class="Symbol">(</a><a id="9087" href="MLTT.Negation.html#319" class="Function Operator">¬</a> <a id="9089" href="TypeTopology.PropTychonoff.html#8799" class="Bound">X</a><a id="9090" class="Symbol">)</a>
  <a id="9094" href="TypeTopology.PropTychonoff.html#9042" class="Function">δ</a> <a id="9096" class="Symbol">(</a><a id="9097" href="MLTT.Plus-Type.html#184" class="InductiveConstructor">inl</a> <a id="9101" href="TypeTopology.PropTychonoff.html#9101" class="Bound">f</a><a id="9102" class="Symbol">)</a> <a id="9104" class="Symbol">=</a> <a id="9106" href="MLTT.Plus-Type.html#184" class="InductiveConstructor">inl</a> <a id="9110" class="Symbol">(</a><a id="9111" href="MLTT.Empty.html#370" class="Function">𝟘-elim</a> <a id="9118" href="MLTT.Pi.html#527" class="Function Operator">∘</a> <a id="9120" href="TypeTopology.PropTychonoff.html#9101" class="Bound">f</a><a id="9121" class="Symbol">)</a>
  <a id="9125" href="TypeTopology.PropTychonoff.html#9042" class="Function">δ</a> <a id="9127" class="Symbol">(</a><a id="9128" href="MLTT.Plus-Type.html#201" class="InductiveConstructor">inr</a> <a id="9132" href="TypeTopology.PropTychonoff.html#9132" class="Bound">ϕ</a><a id="9133" class="Symbol">)</a> <a id="9135" class="Symbol">=</a> <a id="9137" href="MLTT.Plus-Type.html#201" class="InductiveConstructor">inr</a> <a id="9141" class="Symbol">(</a><a id="9142" href="MLTT.Negation.html#1253" class="Function">contrapositive</a> <a id="9157" class="Symbol">(λ</a> <a id="9160" href="TypeTopology.PropTychonoff.html#9160" class="Bound">f</a> <a id="9162" class="Symbol">→</a> <a id="9164" href="MLTT.Empty.html#370" class="Function">𝟘-elim</a> <a id="9171" href="MLTT.Pi.html#527" class="Function Operator">∘</a> <a id="9173" href="TypeTopology.PropTychonoff.html#9160" class="Bound">f</a><a id="9174" class="Symbol">)</a> <a id="9176" href="TypeTopology.PropTychonoff.html#9132" class="Bound">ϕ</a><a id="9177" class="Symbol">)</a>

<a id="9180" class="Markup">\end{code}</a><a id="9190" class="Background">
</a></pre></body></html>